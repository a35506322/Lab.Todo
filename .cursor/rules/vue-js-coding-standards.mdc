---
globs: *.vue, *.js
alwaysApply: false
description: Vue 跟 JS 編碼規範和最佳實踐
---

# Vue 跟 JS 編碼規範和最佳實踐

## 命名規範

1. 變數/函數：小駝峰（如 userProfile、handleClick）
2. 元件檔：PascalCase，[XXX].vue（如 MyButton.vue）
3. 頁面檔：PascalCase，[XXX].vue（如 Home.vue）
4. 一般 JS 檔: 使用 kebab-case：format-date.js
5. 常數：全大寫 + 底線：API_BASE_URL
6. 資料夾：使用 kebab-case：api/、todo-api/、user-profile/
7. API 封裝檔：api-instance.js（axios instance）、services/todo-api.js（todo 相關 API 函數）

## Vue 關鍵寫作規範

1. 基於 Vue3 請始終使用 `Composition API` 與 `<script setup>`
2. 使用 JS 不使用 TS
3. 若無需響應式，為提升效能，請優先選用 `shallowRef` 而非 `ref`
4. 當您需要從 `ref` 推導值時，請優先使用 `computed` 而非 `function`或者 `watch`，以實現自動快取與優化的重新渲染。
5. 請在 `onMounted` 中初始化資料，並請使用 `try catch` 包裹，避免程式崩潰

```vue
<script setup>
import { onMounted } from "vue";

onMounted(async () => {
    try {
        const data = await fetch("/api/data");
    } catch (error) {
        console.error(error);
    }
});
</script>
```

6. 請勿一開始撰寫時就切分 Component 與 Composables，請先撰寫完整功能，再進行切分。
7. 小心 `v-html` 的 XSS 攻擊，使用以下方式避免：

```vue
<script setup>
import { computed } from "vue";
import DOMPurify from "dompurify";

const props = defineProps(["comment", "trustedHtml"]);

// Option 1: Use text interpolation (recommended)
const userComment = computed(() => props.comment);

// Option 2: Sanitize if raw HTML is truly needed
const sanitizedContent = computed(() => DOMPurify.sanitize(props.trustedHtml));
</script>

<template>
    <!-- SAFE: Text interpolation escapes HTML -->
    <div>{{ userComment }}</div>

    <!-- SAFE: Use components for rich content -->
    <CommentRenderer :content="userComment" />

    <!-- SAFE: Only use v-html with trusted, sanitized content -->
    <div v-html="sanitizedContent"></div>
</template>
```

8. 使用 camelCase 進行 style binding 的屬性

```vue
<template>
    <div :style="{ fontSize: '16px' }"></div>
</template>
```

9. 元件庫一律使用 `primevue v4.0+`，樣式一律使用 `tailwindcss v4.0+`
10. 如果需要工具類功能，請一慮先看 VueUse 套件，可使用 `mcp context7` 查詢`VueUse`套件，除非真的沒有才使用自定義 composable

## 禁止事項

1. 不在 `<script setup>` 中使用 `await`但可以在 onMounted 中使用

```vue
<script setup>
❌ 不在 `<script setup>` 中使用 `await`
const data = await fetch("/api/data").then((r) => r.json());

✅ 在 onMounted 中使用 `await`
onMounted(async () => {
    const data = await fetch("/api/data").then((r) => r.json());
});
</script>
```

2. 不使用 `reactive` ，請使用 `ref` 與 `shallowRef` 代替
3. 不要在大資料結構使用 `watch` 時使用

```vue
<script setup>
import { reactive, watch } from "vue";

// Large data structure with many nested properties
const state = reactive({
    users: [], // Could contain thousands of user objects
    products: [], // Each with nested variants, images, etc.
    settings: {
        /* deeply nested config */
    },
});

❌ Traverses entire state tree on every change
watch(
    state,
    (newState) => {
        console.log("State changed");
    },
    { deep: true }
);
</script>
```

4. 不要在 computed 中 modify other state

```vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)

❌ Mutates other state
const doubledCount = computed(() => {
  count.value++  // Side effect - modifying state!
  return count.value * 2
})
</script>
```

5. css 不要針對 DOM 元素進行操作，請使用 class 進行操作。

```vue
<template>
    <article class="article">
        <header>
            <h1>{{ title }}</h1>
            <p>{{ subtitle }}</p>
        </header>
        <section>
            <p>{{ content }}</p>
            <ul>
                <li v-for="item in items" :key="item">{{ item }}</li>
            </ul>
        </section>
    </article>
</template>

<style scoped>
❌ Element selectors are slower when scoped article {
    max-width: 800px;
}
✅ Class selectors are faster when scoped .article {
    max-width: 800px;
}
</style>
```

6. Tailwind 的建置流程無法偵測動態產生的 class 名稱

```vue
<script setup>
const props = defineProps({
    color: String, // 'red', 'blue', 'green'
    size: String, // 'sm', 'md', 'lg'
});
</script>

<template>
    ❌ Tailwind cannot detect these classes
    <div :class="`bg-${color}-500 text-${size}`">Content</div>
</template>
```

8. pinia 的 state 不要隨意修改應使用 actions 進行修改

```vue
<script setup>
import { useCounterStore } from "@/stores/counter";

const store = useCounterStore();

❌ Mutates state directly
store.count++;

✅ Use actions to modify state
store.increment();
</script>
```

9. 撰寫 api 時對應 request 與 response 的屬性命名一律以小駝峰命名

```vue
<script setup>
import { login } from "@/services/auth-api";

❌ 大寫命名 request
const request = {
    UserId: "test",
    Password: "123456",
};

✅ 小駝峰命名 request
const request = {
    userId: "test",
    password: "123456",
};
const { data } = await login(request);

❌ 大寫命名 response
const { Token, ExpiresIn } = data;

✅ 小駝峰命名 response
const { token, expiresIn } = data;
</script>
```

## JS 關鍵寫作規範

1. 函數使用 const = function () {} 代替 function () {}

```js
❌ function () {}
function handleClick() {
    console.log("Click");
}

✅ const = function () {}
const handleClick = () => {
console.log("Click");
};

```

## 專案規範

1. 在 `.vue` 檔案中使用 `useAppToast` 時，在其餘檔案請使用 `useNotificationStore` 統一管理 toast 訊息

```vue
<script setup>
// src/views/Login.vue
import { useAppToast } from "@/composables/useAppToast";

const toast = useAppToast();
</script>
```

```js
// src/services/axios-instance.js
import { useNotificationStore } from "@/stores/useNotificationStore";

const notificationStore = useNotificationStore();
notificationStore.add({
    severity: "error",
    summary: "登入失敗",
    detail: "帳號或密碼不正確，或者登入已過期",
});
```

2. 使用 `<Dialog>` 等彈窗元件時，請使用 `position="top"`，一率都置中往上顯示
3. 驗證表單時錯誤訊息請使用 `FormFieldError` 元件顯示

## Comments

-   避免不必要的註解：程式碼應具有自明性
-   解釋「為什麼」而非「如何做」：註解應描述背後的邏輯或意圖，而非程式碼的執行內容

## 外部資源參考

如果有任何疑問可以參考以下資源：

1. mcp context7
2. [Vue 最佳實踐規則](https://github.com/antfu/skills/blob/main/skills/vue-best-practices/SKILL.md)

正常來說使用 `mcp context7` 進行查詢最佳使用做法
但發生如果有些異常情況無法解決優先查詢 Vue 最佳實踐規則
